# 백트래킹
- 백트래킹
- 순열
## 백트래킹
- 백트래킹
    - 가능한 모든 경우를 탐색하는 중 해답으로 이어지지 않은 경우에 대해서는 탐색하지 않고 되돌아가며 해결하는 알고리즘 기법
    - 유망 : 현재 상태(노드, 경로)가 문제의 해답으로 발전할 가능성이 높은지를 판단하는 기준
    - 가지치기 : 탐색 중 불필요한 경로를 제거하여 탐색의 효율성을 높이는 방법
- 완전 탐색 vs 백트래킹
    - 모든 경우의 수를 고려하는 완전 탐색(브루트 포스)와는 달리 모든 경우의 수를 고려하지 않음
    - 일반적으로 경우의 수가 줄어들지만 최악의 경우에는 여전히 지수함수 시간을 요하므로 해결이 불가능
        1. 가지치기가 거의 이루어지지 않은 상황
        2. 문제가 매우 큰 입력을 가지는 상황
        3. 유효한 해답이 거의 없는 상황
        4. ...
- N-Queen 문제
    - N*N 크기의 체스 판 위에 N개의 Queen 들을 서로 위협하지 않게 배치하는 문제
- 8-Queen 문제
    - 8*8 크기의 체스 판 위에 8개의 Queen 들을 서로 위협하지 않게 배치하는 모든 경우의 수를 구하는 문제
    - 모든 경우의 수는 ${64 \choose 8}$ = 4,426,165,368
    - 실제 정답의 수는 92개
    - 모든 경우의 수 속에서 92개를 최대한 효율적으로 찾아내는 것이 관건

## 순열
### 순열
- 순열 : 서로 다른 원소들을 특정한 순서로 나열하는 것
- 서로 다른 n개의 원소를 가지는 집합에서 r개를 뽑아 순서 있게 나열하는 경우를 다음과 같이 표현할 수 있음
    - ${}^nP_r$ = n*(n-1)* ... *(n-r+1)
- 서로 다른 n개의 원소 집하베서 n개를 뽑아 나열하는 경우를 팩토리얼이라고 함
    - n! = n*(n-1)*...*(1)
- 순열을 활용하는 문제
    - 0 ~ 9 까지의 숫자를 활용하여 4자리의 비밀번호를 만드는 경우 만들 수 있는 경우의 수를 구하시오.
    - 5명의 사람을 줄로 세우려고 합니다. 경우의 수를 구하시오.
    - A, B, C, D 도시가 있습니다. 방문할 수 있는 경우의 수는 얼마인지 구하시오.
    - 등
- 순열 구현 (반복문)
    - 세우려는 원소의 개수만큼 반복문 반복
- 순열 구현 (swap)

```
// arr[] : 데이터가 저장된 배열
// swap(i,j): arr[i] <--교환 --> arr[j]
// n: 원소의 개수, k: 현재까지 교환된 원소의 개수 
perm(n,k)
    IF k == n
        print array
    ELSE
        For i in k -> n-1
            swap(k,i);
            perm(n,k+1);
            swap(k,i);
```

- 순열 구현 (방문체크)
    - k개의 원소를 순서대로 추가하는데 기존에 쓰이지 않던 원소만 추가 가능(check배열로 확인)
- 순열 구현 (비트마스킹)
    - 방문체크를 boolean배열이 아닌 비트마스킹으로 하는 것

- 순열의 확장 개념 (생각해볼 필요가 있는 문제)
    - 중복 순열 -> 원소를 뽑을 때 중복을 허용하는 경우, ex) {A,B} 원소를 중복을 허용하여 나열하는 경우
    - 원형 순열 -> 배열할 때 원형으로 배열하는 경우 ex) n명의 사람을 원형 테이블에 앉히는 방법