# 그래프 탐색(Graph)
- 깊이 우선 탐색
- 너비 우선 탐색

## 깊이 우선 탐색(Depth First Search)
### 깊이 우선 탐색 (DFS)
- DFS
    - 깊이 우선 탐색
    - 시작 지점에서 출발하여 한 방향으로 탐색
    - 진행 할 수 없다면 마지막에 만난 지점으로 돌아와 다른 방향 다시 탐색
    - 후입 선출 구조의 스택 사용
    - 재귀함수는 System Stack을 활용하므로 간단하게 구현 가능
- 트리 탐색
    1. 루트 노드 -> Stack Push
    2. Stack -> Empty가 될 때까지 반복 수행
        1. 현재 노드 -> Stack pop
        2. 현재 노드의 모든 자식 -> Stack Push
- 트리 탐색 (재귀 함수)
    - 현재 노드 (v) 방문
    - (v)의 자식 노드 (w)를 차례로 재귀 호출

```
DFS(v){
    v 방문;
    for w in (v의 모든 자식){
        DFS(w);
    }
} 
```

- 그래프 탐색
    - 위와 같은 방식으로 그래프를 처리하면 같은 곳을 방문하는 문제점이 생긴다. 
    - 따라서 방문 배열로 이를 방지한다.
- 미로 찾기 (배열 탐색)
    - 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제이다.
    - 이동할 수 있는 방향은 4방향으로 제한한다.
    - 델타 검색을 할 때 배열을 벗어나는 경우를 생각해야 됨
        - 배열의 외부(1칸씩)를 1로 채운다면 이를 고려하지 않아도 됨

```
DFS(r,c){
    visited[r][c] <- TRUE   // v 방문 설정

    FOR (r,c) 를 기준으로 4방향 탐색
        IF 다음 좌표는 이동 가능한 것인지 체크
            DFS(nr,nc) 
} 
```

## 너비 우선 탐색(Breadth First Search)
### 너비 우선 탐색(BFS)
- BFS
    - 너비 우선 탐색
    - 시작 지점에 인접한 순으로 탐색을 시작함.
    - 인접한 지점을 모두 방문하였다면 다음으로 인접한 지점을 방문함.
    - 선입 선출 구조의 Queue 자료구조를 사용
    - 너비 우선 탐색을 시작 지점과 끝 지점이 주어졌을 때 최단 길이를 구할 수 있음
- 트리 탐색
    1. 루트 노드 Queue에 삽입
    2. Queue가 공백이 될 때까지 반복 수행
        1. Queue에서 원소 (Curr) 꺼내기
        2. 해당 원소 방문
        3. Curr의 자식 노드 Queue에 삽입
- 그래프 탐색
    - DFS와 마찬가지로 방문배열을 생성해야 함.
- 미로 탈출 길이 (배열 탐색)
    - 아래 그림과 같이 입구와 출구가 주어진 미로에서 입구부터 출구까지의 길이를 찾는 문제이다.
    - 이동할 수 있는 방향은 4방향으로 제한한다.
- 최단 길이 구하는 방법
    1. 2차원 배열을 만들어 직접 길이를 저장한다.
    2. 큐에 넣을 때 같이 넣어 저장한다. (클래스 멤버 변수로 함께 저장)
    3. 길이를 저장하는 변수를 생성하여 이를 활용한다. (Queue size를 묶어 같은 레벨끼지 처리)
     